## OOP

```java
객체지향언어(OOP) - 캡슐화
클래스 - 부품(조립)

1. 클래스 설계
  static 필드    = 스태틱 필드             <- public
  필드           = 인스턴스 필드 데이터(변수)  <- private  r,w 접근메서드(setter, getter)

  생성자          = 필드 초기화  <- 오버로딩(중복선언): 매개변수 형식과 갯수는 달라야 함
  메서드          = 기능(동작)  <- public


2. 객체 생성 = 인스턴스
   Student student = new Student();

3. 객체 사용
     참조변수.get필드()   getName()
           **메서드**
                   접근제어자  리턴타입  메서드이름 ( 매개변수타입) { }
                   public  void   add    ( int ... a){ return }
                   public  int   add     ( int ... a){ return 값 }


클래스변수 = 스태틱(정적)변수 = 동일한 클래스로 생성된 객체가 공유하는 필드
   Math.PI
인스턴스변수 = 생성된 객체별로 각각
```

## 절차지향과 객체지향 차이

### 덧셈 계산 기능 구현하기

1. 절차지향 언어로 짠 프로그램

```java
public class MainApp1 {

	public static void main(String[] args) {
		System.out.println("====================");
		System.out.println("=======header=======");
		System.out.println("====================");

		System.out.println(String.format("%d + %d = %d", 5,3,5+3) );

		System.out.println("====================");
		System.out.println("=======footer=======");
		System.out.println("====================");
	}
}
```

2. 반복되는 코드나 특정 기능을 수행하는 코드 영역을 메서드로 만들기

```java
public class MainApp2 {

	public static void main(String[] args) {
    //코드를 기능별로 분리하여 함수로 만들고 호출하도록 함.
    //메인 메서드만 보면 되므로 가독성도 뛰어나고 유지보수도 편함
		printHeader();
		add(5,3);
		printFooter();

	}

	public static void add(int a, int b) {
		System.out.println(String.format("%d + %d = %d", a,b,a+b) );
	}

	public static void printHeader() {
		System.out.println("====================");
		System.out.println("=======header=======");
		System.out.println("====================");
	}

	public static void printFooter() {
		System.out.println("====================");
		System.out.println("=======footer=======");
		System.out.println("====================");
	}
}
```

3. 객체지향 언어로 짠 프로그램
   코드를 재활용 할 수 있도록 별도의 클래스(Calc)로 만들고 MainApp3 에서 Calc 클래스를 사용합니다.

```java
public class MainApp3 {

	public static void main(String[] args) {
		int kor=100;
		int eng=100;

		Calc calc = new Calc(kor, eng);
		calc.printMsg("header");
		calc.printMsg("footer");
		calc.add();
	}

}
```

```java
public class Calc {
	private int kor;
	private int eng;

	public Calc(int kor, int eng) {
		this.kor = kor;
		this.eng = eng;
	}

	public void add() {
		System.out.println(String.format("%d + %d = %d",
				                         kor,eng,kor+eng) );
	}

	public void printMsg(String msg) {
		System.out.println("====================");
		System.out.println("=======header=======");
		System.out.println("====================");
	}
}
```

객체지향은 재사용하고 쉽게 배포할 수 있도록 설계를 해야함.  
절차지향에서는 필요한 코드가 있으면 코드 자체를 복사를 해야해지만 클래스인 경우는 클래스 파일만 배포하면 됨.

3. 프로그램 개발 단계
   1. 요구사항 분석
   2. 데이터와 함수 추출 (vue의 data와 methods와 같음)
   3. 클래스 설계 : Calc 클래스 선언
   4. 클래스 사용하기 : MainApp에서 Calc 클래스를 사용

## 클래스

- 클래스
- 필드
- 생성자 / 오버로딩
- 메서드 / 오버로딩 / 오버라이딩
- 인스턴스 맴버 / 스태틱 맴버
- 상속 / 인터페이스 / 추상클래스

1. VO

```java
public class AddrStudent {

	private String name;  //이름
	private String tel;   //전화번호

	private String lesson; //학과
	private int grade;  //학년
}
```

2. 리스트에 객체를 생성하여 추가

```java
		List<AddrStudent> list = new ArrayList<>();
		AddrStudent addr1 = new AddrStudent("홍길동", "011-1111");
		list.add(addr1);
```

3. 객체를 생성자와 setter 추가

```java
public AddrStudent() {}

	//생성자
	public AddrStudent(String name, String tel) {
		super();
		this.name = name;
		this.tel = tel;
	}

	public void setName(String name) {
		this.name = name;
	}

	public void setTel(String tel) {
		this.tel = tel;
	}
```

4. 리스트에 다른 형태의 주소록도 저장하려면?

```java
public class AddrCompany  {
	private String name;  //이름
	private String tel;   //전화번호
	private String companyName;  //회사명
	private String position;  //직위
}
```

```java
		List<AddrStudent> list = new ArrayList<>();
		AddrStudent addr1 = new AddrStudent("홍길동", "011-1111");
		list.add(addr1);

		AddrCompany addr2 = new AddrCompany("홍길동", "011-1111");
		list.add(addr2);
```

6. 일반화. 부모클래스 생성하고 상속

```java
package my.addr;

public class Addr {

	private String name;
	private String tel;
}
public class AddrCompany  extends Addr {}
public class AddrStudent  extends Addr {}

List<Addr> list = new ArrayList<>();
```
