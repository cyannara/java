## 수업목표

- 상속 인터페이스와 추상클래스
- 형변환, 객체타입확인(instanceof)
- 제네릭
- 람다표현식
- 스트림

### 제네릭

- 제네릭은 타입을 제한하여 원치 않는 타입의 값이 들어가는 경우엔 컴파일에러를 발생하고
- 값 꺼내올때는 자동으로 형변환을 처리해주어 반복적인 형체크, 형변환 코드를 없애주는 역할

generic 타입을 사용하지 않은 경우

```java
		List list1 = new ArrayList();

		list1.add(5400);
		Integer p1 = (Integer)list1.get(0);			//타입변환 필요함.

		list1.add("no use Generic type");
		Integer p2 = (Integer)list1.get(0);			//실행 시 타입변환 에러 발생
```

generic 타입을 사용한 경우

```java
		List<Integer> list2 = new ArrayList<>();

		list2.add(500);                       //Integer로 저장
		list2.add("use generic type");			  //컴파일 시 타입 체크 에러 발생
		Integer p3 = list2.get(0);						//타입변환 필요없음.
```

제네릭 메서드

```java
	public static <T> List<T> firstThree(List<T> list) {
      if (list == null) return Collections.emptyList();
	    return list.stream().limit(3).collect(Collectors.toList());
	}

   public static void main(String[] args) {
        List<String> names = Arrays.asList("Kim", "Lee", "Park", "Choi", "Jung");
        List<Integer> scores = Arrays.asList(10, 20);

        System.out.println(firstThree(names));   // [Kim, Lee, Park]
        System.out.println(firstThree(scores));  // [10, 20]
    }
```

### 람다표현식

익명클래스

```java
 .sort(new Comparator<Student>() {                         //익명클래스
	    			    @Override
	    			    public int compare(Student s1, Student s2) {
	    			        return s1.getName().compareTo(s2.getName());
	    			    }
	    			})
```

람다식으로 직접 compare()를 구현

```java
sort( (Student o1, Student o2)-> o1.getName().compareTo(o2.getName() )  )
```

static method

```java
sort(Comparator.comparing((Student s) -> s.getName()))
```

메서드 참조(더블콜론- 람다표현식 축약문법)

```java
sort(Comparator.comparing(Student::getName))
```
